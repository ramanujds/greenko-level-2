# Logging in Microservices

In monoliths:

* Logs = “print what happened”

In microservices:

* Logs = **distributed evidence**

You are no longer debugging *one process*, you’re reconstructing **a story across services**.

That’s why **patterns** matter.
---

## The 3 Core Logging Patterns You MUST Use

1. **Structured Logging**
2. **Correlation ID**
3. **Trace ID (Distributed Tracing)**


---

# Structured Logging

## What it is

> Logs written in a **machine-readable format** (usually JSON), not plain text.

### Bad (human-only logs)

```
User 123 failed to place order
```

### Good (structured)

```json
{
  "timestamp": "2026-02-11T10:15:32Z",
  "level": "ERROR",
  "service": "inventory-service",
  "message": "Failed to reserve inventory",
  "userId": "123",
  "orderId": "ORD-9912"
}
```

## How it’s usually implemented

* JSON encoder (Logback / Log4j2)
* Logs shipped to:

    * **ELK Stack**
    * or Grafana Loki

Example (Logback JSON encoder):

```yaml
logging:
  pattern:
    console: '{"level":"%level","service":"inventory-service","msg":"%msg"}'
```

---

## Why structured logging is a must

> If your logs can’t be queried by fields, they’re not production logs.

---

# Correlation ID

## What it is

> A **request identifier** that stays the same across services.

Example:

```
X-Correlation-Id: 9f8a-72bc
```

---

## Why Correlation ID exists

* Tracing might be sampled (not 100%)
* Logs are always written
* Correlation ID gives you **minimum observability guarantee**

---

## How it works 

```
Client
  ↓ (X-Correlation-Id)
Gateway
  ↓
Inventory Service
  ↓
Pricing Service
```

Every log line contains:

```
correlationId=9f8a-72bc
```

---

## Where Correlation ID is created

✔ API Gateway (best place)
✔ Or first entry service

Never create it in every service.

---

## Example log with correlation ID

```
INFO [correlationId=9f8a-72bc] Reserving inventory
```

---

## Implementation idea 

* Gateway generates ID
* Adds header
* Services propagate it
* Logging framework pulls it from MDC

---

## When Correlation ID saves you

* Zipkin sampling = 10%
* Request not traced
* Customer complains
* You search logs by correlation ID
* You still find the story

---

# Trace ID 

## What it is

> A **globally unique ID** representing *one request across all services*.

Provided by tracing systems like:

* **Zipkin**
* Jaeger
* Tempo

---

## Trace ID vs Correlation ID

- Trace ID is generated by tracing system, Correlation ID is generated by gateway
- Trace ID is used for distributed tracing, Correlation ID is used for log correlation
- Trace ID is visualized in Zipkin, Correlation ID is not

## How Trace ID works

```
Trace ID: abc-123
  ├── Gateway span
  ├── Inventory span
  ├── Feign call span
  └── Pricing span
```

This is what Zipkin visualizes.

---

## Why Trace ID must be in logs

Tracing without logs = incomplete
Logs without trace = fragmented

### Ideal log format

```
INFO [traceId=abc123 spanId=def456 correlationId=9f8a] Fetching inventory
```

Now you can:

* Start in Zipkin
* Jump to logs
* Jump back to trace

---

## Logging Rules for Microservices

### Do this

* JSON logs
* Include service name
* Include environment
* Include traceId
* Include correlationId
* Log at boundaries (entry/exit)


